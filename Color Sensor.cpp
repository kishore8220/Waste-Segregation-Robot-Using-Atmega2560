#define F_CPU 14745600
#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>
#include <math.h> //included to support power function
#include "lcd.h"
#include "firebird_avr.h"	

volatile unsigned long int pulse = 0; //to keep the track of the number of pulses generated by the color sensor
volatile unsigned long int red;       // variable to store the pulse count when read_red function is called
volatile unsigned long int blue;      // variable to store the pulse count when read_blue function is called
volatile unsigned long int green;     // variable to store the pulse count when read_green function is called

void lcd_port_config (void)
{
	DDRC = DDRC | 0xF7; //setting all the LCD pin's direction set as output
	PORTC = PORTC & 0x80; //setting all the LCD pins are set to logic 0 except PORTC 7
}

void color_sensor_pin_config(void)
{
	DDRD  = DDRD | 0xFE; //set PD0 as input for color sensor output
	PORTD = PORTD | 0x01; //Enable internal pull-up for PORTD 0 pin
}

void motor_pin_config(void)
{
	DDRA |= 0x0F;  // Setting pins PA0-PA3 as output for motor control
	DDRL |= 0x18;  // Setting pins PL3 and PL4 as output for PWM
}

void ir_sensor_pin_config(void)
{
	DDRF = 0x00; //set PORTF direction as input for IR sensors
	PORTF = 0x00; //ensure internal pull-ups are disabled
}

void port_init(void)
{
	lcd_port_config(); //lcd pin configuration
	color_sensor_pin_config(); //color sensor pin configuration
	motor_pin_config(); //motor pin configuration
	ir_sensor_pin_config(); //IR sensor pin configuration
}

void color_sensor_pin_interrupt_init(void) //Interrupt 0 enable
{
	cli(); //Clears the global interrupt
	EICRA = EICRA | 0x02; // INT0 is set to trigger with falling edge
	EIMSK = EIMSK | 0x01; // Enable Interrupt INT0 for color sensor
	sei(); // Enables the global interrupt
}

//ISR for color sensor
ISR(INT0_vect)
{
	pulse++; //increment on receiving pulse from the color sensor
}

void init_devices(void)
{
	cli(); //Clears the global interrupt
	port_init();  //Initializes all the ports
	color_sensor_pin_interrupt_init();
	sei();   // Enables the global interrupt
}

//Filter Selection
void filter_red(void)    //Used to select red filter
{
	//Filter Select - red filter
	PORTD = PORTD & 0xBF; //set S2 low
	PORTD = PORTD & 0x7F; //set S3 low
}

void filter_green(void)  //Used to select green filter
{
	//Filter Select - green filter
	PORTD = PORTD | 0x40; //set S2 High
	PORTD = PORTD | 0x80; //set S3 High
}

void filter_blue(void)   //Used to select blue filter
{
	//Filter Select - blue filter
	PORTD = PORTD & 0xBF; //set S2 low
	PORTD = PORTD | 0x80; //set S3 High
}

void filter_clear(void)  //select no filter
{
	//Filter Select - no filter
	PORTD = PORTD | 0x40; //set S2 High
	PORTD = PORTD & 0x7F; //set S3 Low
}

//Color Sensing Scaling
void color_sensor_scaling()     //This function is used to select the scaled down version of the original frequency of the output generated by the color sensor, generally 20% scaling is preferable, though you can change the values as per your application by referring datasheet
{
	//Output Scaling 20% from datasheet
	//PORTD = PORTD & 0xEF;
	PORTD = PORTD | 0x10; //set S0 high
	//PORTD = PORTD & 0xDF; //set S1 low
	PORTD = PORTD | 0x20; //set S1 high
}
//

int red_read(void) // function to select red filter and display the count generated by the sensor on LCD. The count will be more if the color is red. The count will be very less if its blue or green.
{
	//Red
	filter_red(); //select red filter
	pulse=0; //reset the count to 0
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	red = pulse;  //store the count in variable called red
	
	lcd_cursor(1,1);  //set the cursor on row 1, column 1
	lcd_string("Red Pulses"); // Display "Red Pulses" on LCD
	lcd_print(2,1,red,5);  //Print the count on second row
	_delay_ms(1000);	// Display for 1000ms or 1 second
	lcd_wr_command(0x01); //Clear the LCD
	
	return red;
}

int green_read(void) // function to select green filter and display the count generated by the sensor on LCD. The count will be more if the color is green. The count will be very less if its blue or red.
{
	//Green
	filter_green(); //select green filter
	pulse=0; //reset the count to 0
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	green = pulse;  //store the count in variable called green
	
	lcd_cursor(1,1);  //set the cursor on row 1, column 1
	lcd_string("Green Pulses"); // Display "Green Pulses" on LCD
	lcd_print(2,1,green,5);  //Print the count on second row
	_delay_ms(1000);	// Display for 1000ms or 1 second
	lcd_wr_command(0x01); //Clear the LCD
	return green;
}

int blue_read(void) // function to select blue filter and display the count generated by the sensor on LCD. The count will be more if the color is blue. The count will be very less if its red or green.
{
	//Blue
	filter_blue(); //select blue filter
	pulse=0; //reset the count to 0
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	blue = pulse;  //store the count in variable called blue
	
	lcd_cursor(1,1);  //set the cursor on row 1, column 1
	lcd_string("Blue Pulses"); // Display "Blue Pulses" on LCD
	lcd_print(2,1,blue,5);  //Print the count on second row
	_delay_ms(1000);	// Display for 1000ms or 1 second
	lcd_wr_command(0x01); //Clear the LCD
	return blue;
}

// Function to initialize the motors
void motor_init(void) {
	// Configure motor control pins as output
	DDRA |= 0x0F;  // Setting pins PA0-PA3 as output for motor control
	DDRL |= 0x18;  // Setting pins PL3 and PL4 as output for PWM

	// Set Fast PWM mode for Timer5 with non-inverted output
	TCCR5A |= (1 << WGM50) | (1 << WGM51) | (1 << COM5A1) | (1 << COM5B1);
	TCCR5B |= (1 << WGM52) | (1 << WGM53) | (1 << CS51);  // Prescaler = 8
	ICR5 = 39999;  // TOP value for 50Hz PWM
}

// Function to move the robot forward
void move_forward(void) {
	PORTA = 0x06;  // Set direction for forward motion
	OCR5A = 20000; // Set speed for left motor
	OCR5B = 20000; // Set speed for right motor
}

// Function to stop the robot
void stop(void) {
	PORTA = 0x00;  // Stop both motors
	OCR5A = 0;     // Stop PWM for left motor
	OCR5B = 0;     // Stop PWM for right motor
}
void servo1_pin_config (void)
 {
  	servo_ddr_reg  |= (1 << servo_1_pin);  		//making Servo 1 pin output
  	servo_port_reg |= (1 << servo_1_pin); 		//setting servo 1 pin to logic 1
 }

 void servo2_pin_config (void)
 {
  	servo_ddr_reg  |= (1 << servo_2_pin);  		//making Servo 2 pin output
	 servo_port_reg |= (1 << servo_2_pin); 		//setting servo 2 pin to logic 1
 }
void servo3_pin_config (void)
{
 	servo_ddr_reg  |= (1 << servo_3_pin);  		//making Servo 3 pin output
 	servo_port_reg |= (1 << servo_3_pin); 		//setting servo 3 pin to logic 1
}
void timer1_init(void)
{
 	TCCR1B_reg &= ~(1 << CS2_bit | 1 << CS1_bit | 1 << CS0_bit); 			//stop the timer
 	
	TCNT1H_reg = 0xFC; 			//Counter high value to which OCR1xH value is to be compared with
 	TCNT1L_reg = 0x01;			//Counter low value to which OCR1xH value is to be compared with
 	OCR1AH_reg = 0x03;			//Output compare Register high value for servo 1
 	OCR1AL_reg = 0xFF;			//Output Compare Register low Value For servo 1
 	OCR1BH_reg = 0x03;			//Output compare Register high value for servo 2
 	OCR1BL_reg = 0xFF;			//Output Compare Register low Value For servo 2
 	OCR1CH_reg = 0x03;			//Output compare Register high value for servo 3
 	OCR1CL_reg = 0xFF;			//Output Compare Register low Value For servo 3

	//{COM1A1=1, COM1A0=0; COM1B1=1, COM1B0=0; COM1C1=1 COM1C0=0} For Overriding normal port functionality to OCRnA outputs.
	//{WGM11=1, WGM10=1} Along With WGM12 in TCCR1B for Selecting FAST PWM Mode
 	TCCR1A_reg |= (1 << COMA1_bit | 1 << COMB1_bit | 1 << COMC1_bit | 1 << WGM1_bit | 1 << WGM0_bit); 
	TCCR1A_reg &= ~(1 << COMA0_bit | 1 << COMB0_bit | 1 << COMC0_bit);

	//WGM12=1; CS12=1, CS11=0, CS10=0 (Prescaler=256)
 	TCCR1B_reg |= (1 << WGM2_bit | 1 << CS2_bit); 
	TCCR1B_reg &= ~(1 << CS1_bit | CS0_bit);
}

/**
 * @brief      Function to rotate Servo 1 by a specified angle in the multiples of 1.86 degrees
 */
void servo_1(unsigned char degrees)  
{
 	float PositionPanServo = 0;
  	PositionPanServo = ((float)degrees / 1.86) + 35.0;
 	OCR1AH_reg = 0x00;
 	OCR1AL_reg = (unsigned char) PositionPanServo;
}
// 
// /**
//  * @brief      Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
//  */
 void servo_2(unsigned char degrees)  
 {
  	float PositionPanServo = 0;
   	PositionPanServo = ((float)degrees / 1.86) + 35.0;
  	OCR1BH_reg = 0x00;
  	OCR1BL_reg = (unsigned char) PositionPanServo;
 }

/**
 * @brief      Function to rotate Servo 3 by a specified angle in the multiples of 1.86 degrees
 */
void servo_3(unsigned char degrees)  
{
 	float PositionPanServo = 0;
  	PositionPanServo = ((float)degrees / 1.86) + 35.0;
 	OCR1CH_reg = 0x00;
 	OCR1CL_reg = (unsigned char) PositionPanServo;
}

//----------------------------- SERVO FREE FUNCTIONS ----------------------------------------------

/**
 * @brief      Function to free the Servo 1
 * 
 * @details    Servo_free functions unlocks the servo motors from the any angle and make them free by giving 100% duty cycle at the PWM. 
 * 			   This function can be used to reduce the power consumption of the motor if it is holding load against the gravity. 
 */
void servo_1_free (void) //makes servo 1 free rotating
{
 	OCR1AH_reg = 0x03; 
 	OCR1AL_reg = 0xFF; 			//Servo 1 off
}

/**
 * @brief      Function to free the Servo 2
 * 
 * @details    Servo_free functions unlocks the servo motors from the any angle and make them free by giving 100% duty cycle at the PWM. 
 * 			   This function can be used to reduce the power consumption of the motor if it is holding load against the gravity. 
 */
void servo_2_free (void) //makes servo 2 free rotating
{
 	OCR1BH_reg = 0x03; 
 	OCR1BL_reg = 0xFF; 			//Servo 2 off
}

/**
 * @brief      Function to free the Servo 3
 * 
 * @details    Servo_free functions unlocks the servo motors from the any angle and make them free by giving 100% duty cycle at the PWM. 
 * 			   This function can be used to reduce the power consumption of the motor if it is holding load against the gravity. 
 */
void servo_3_free (void) //makes servo 3 free rotating
{
 	OCR1CH_reg = 0x03; 
 	OCR1CL_reg = 0xFF; 			//Servo 3 off
}
void sensors_control_pins_config (void) {

	// Configure the control pin of 3 White Line Sensors
	//wl_pwr_ctrl_ddr_reg			|= ( 1 << wl_pwr_ctrl_pin );
	
	// Configure the control pin of all Sharp Sensors
	//sharp_pwr_ctrl_ddr_reg		|= ( 1 << sharp_pwr_ctrl_pin );
	
	// Configure the control pin of all 8 IR Proximity Sensors
	ir_prox_pwr_ctrl_ddr_reg	|= ( 1 << ir_prox_pwr_ctrl_pin );
}
/**
 * @brief      Function to turn ON all IR Proximity Sensors
 */
void turn_on_ir_proxy_sensors (void) {

	// Turn ON the control pin of all IR Proximity Sensors
	ir_prox_pwr_ctrl_port_reg	&= ~( 1 << ir_prox_pwr_ctrl_pin );
}


/**
 * @brief      Function to turn OFF all IR Proximity Sensors
 */
void turn_off_ir_proxy_sensors (void) {

	// Turn OFF the control pin of all IR Proximity Sensors
	ir_prox_pwr_ctrl_port_reg	|= ( 1 << ir_prox_pwr_ctrl_pin );
}

/**
 * @brief      Function to turn ON all the sensors by turning ON the respective MOSFET switches
 */
void turn_on_all_sensors (void) {
	
	// Turn ON the control pin of 3 White Line Sensors
	//turn_on_wl_sensors();
	
	// Turn ON the control pin of all Sharp Sensors
	//turn_on_sharp_sensors();
	
	// Turn ON the control pin of all IR Proximity Sensors
	turn_on_ir_proxy_sensors();
}


/**
 * @brief      Function to turn OFF all the sensors by turning OFF the respective MOSFET switches
 */
void turn_off_all_sensors (void) {
	
	// Turn OFF the control pin of 3 White Line Sensors
	//turn_off_wl_sensors();
	
	// Turn OFF the control pin of all Sharp Sensors
	//turn_off_sharp_sensors();
	
	// Turn OFF the control pin of all IR Proximity Sensors
	turn_off_ir_proxy_sensors();
}


int main(void)
{
	init_devices();
	lcd_set_4bit();
	lcd_init();
	color_sensor_scaling();
	motor_init();
	servo1_pin_config();
	servo2_pin_config();
	servo3_pin_config();
	timer1_init();
    sensors_control_pins_config();
	  
	 servo_1(160);
	 _delay_ms(1000);
	 servo_2(0);
	 _delay_ms(1000);
	  
	while (1)
	{   
		turn_off_all_sensors();			// Turn OFF all the sensors by turning OFF the respective MOSFET switches
		_delay_ms(1000);
			turn_on_all_sensors();			// Turn ON all the sensors by turning ON the respective MOSFET switches
			_delay_ms(1000);
	        _delay_ms(5000);
 			move_forward();
 	        turn_on_ir_proxy_sensors();		// Turn ON IR Proximity Sensors
 			_delay_ms(1000);
			
		if(turn_on_ir_proxy_sensors > 0)
			{
				stop();
				_delay_ms(500);
			}
	 		
		else
			{
				turn_off_ir_proxy_sensors();	// Turn OFF IR Proximity Sensors
				_delay_ms(500);
			}
			
		if (red_read() > blue_read() && red_read() > green_read())
		{
			//lcd_string(2 , 1 , "Red Pulse");
			servo_3(30);
			_delay_ms(500);
			
		}
		
		else if(green_read() > red_read() && green_read() > blue_read())
		{
		//	lcd_string(2 , 1 , "Green Pulse");
			servo_3(60);
			_delay_ms(500);
		}
		
		else if(blue_read() > red_read() && blue_read() > green_read())		
		{
			//lcd_string(2 , 1 , "Blue Pulse");
			servo_3(90);
			_delay_ms(500);
		}		
		 servo_2(160);
		 _delay_ms(3000);
		  servo_1(0);
		  _delay_ms(3000);
		  servo_2(0);
		  _delay_ms(1000);
		  	servo_1(160);
		  	_delay_ms(1000);
	}
	return 0;
}

